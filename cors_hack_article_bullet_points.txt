CORS bypassing through cUrl + attack source obfuscation with ProxyChains vs TOR

1) Getting Up the (docker) server with CORS rules

2) Testing the usual case scenario vs malicious one

3) Bypassing the CORS rules by HTTP header tampering

4) Getting Up the (docker) server with ProxyChains

5) Tunneling the cUrl attack through PC

6) Tunneling the cUrl attack through PC

7) Analyzing the server logs and conclusions

CORS PROTECTION vs BYPASSING ANALYSIS

Pessoal, durante o desenvolvimento de uma PoC de hacking-CORS para nossa solução, tenho constatado o seguinte (o que contraria meus testes iniciais, que demontraram um resultado falso-positivo para o bypassing por equívoco (cache) no manuseio das imagens docker do experimento).

A proteção CORS (Cross-Origin Resource Sharing) é reforçada pelos browsers (modernos) de modo que o header Origin não seja facilmente adulterado no client-side. Vale ressaltar que o CORS não serve para restringir a chamada aos endpoints da API, mas sim impedir o carregamento no browser do código retornado pelo servidor. A princípio, a aplicação do CORS nos possibilitaria proteger carregamentos indevidos do Código de Monitoramento (e outros scripts nossos) em domínios não autorizados. Isso seria complementar à validação dos domínios autorizados no backend (Gyruss)

Assim sendo, tenho testado pelo menos estes dois cenários:

1) Requisição para recurso protegido por CORS via XHR (XmlHttpRequest)

* Ao tentar adulterar o header origin via setRequestHeader(), o header original é preservado
* Ao tentar adulterar o header via headers adicionais (passados como argumento ao xhr.send()), o header original é preservado

2) Requisição para recurso protegido por CORS via fetch

* Ao tentar adulterar o header via campos adicionais (passados como argumento ao fetch()), o header original é preservado
* Ao tentar adulterar o header pela edição de requests do browser, a regra de CORS ainda prevalece

Navegadores testados:

Mozila Firefox 68.5
Chromium 79
Google Chrome (2018 old version) 70

Diagnóstico preliminar:

É possível (teoricamente) fazer o bypassing[1] usando um proxy (CORS-anywhere [2]) que encapsularia o header Origin adulterado, permitindo o carregamento do recurso protegido. Irei validar tal hipótese, como próximo passo.

Assim que tiver a PoC finalizada, publico ela no github e atualizo aqui. Quem quiser juntar forças na experimentação também é mais do que bem-vindo(a).

[1] - https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646
[2] - https://cors-anywhere.herokuapp.com/

